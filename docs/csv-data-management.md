# ゲームデータをCSVで管理する方法

## 概要

ゲームのマスターデータ（スキル、敵、アイテムなど）をCSVファイルで管理し、実行時にパースしてゲームで使用する仕組みです。Excelやスプレッドシートで編集できるため、非エンジニアでもデータ調整が可能になります。

---

## CSVファイルの構造（3行ヘッダー方式）

```
1行目: カラム名（name, icon, damage など）
2行目: 型定義（string, number, boolean）
3行目以降: 実際のデータ
```

### 例: skills.csv

```csv
name,icon,damage,manaCost,rarity
string,string,number,number,string
スラッシュ,sword.png,100,0,C
ファイアボール,fire.png,200,30,R
```

### ポイント

- 2行目で型を指定することで、パーサーが自動的に数値変換してくれる
- `number`指定のカラムは自動で`parseInt/parseFloat`される
- `boolean`指定のカラムは`true/false`や`1/0`をbooleanに変換

---

## CSVパーサーの役割

1. CSVテキストを行ごとに分割
2. 1行目からカラム名を取得
3. 2行目から型情報を取得
4. 3行目以降のデータを、型情報に基づいて変換
5. JavaScriptオブジェクトの配列として返す

### 注意点: カンマを含むフィールド

JSONや説明文など、カンマを含む値を入れたい場合は**ダブルクォートで囲む**必要があります。

```
悪い例: {"value":30,"target":"敵"}  ← カンマで分割されてしまう
良い例: "{""value"":30,""target"":""敵""}"  ← ダブルクォートで囲む
```

### RFC 4180ルール

- フィールド全体をダブルクォートで囲む
- フィールド内のダブルクォートは `""` と2つ重ねてエスケープ

---

## データローダーの役割

CSVパーサーが返す「生データ」を、ゲームで使いやすい形に変換します。

### 変換の例

1. **文字列 → 列挙型**: `rarity: "SSR"` → `rarity: Rarity.SSR`
2. **JSON文字列 → オブジェクト**: `effectParams: "{...}"` → `effectParams: { value: 30 }`
3. **ID → 参照オブジェクト**: `traitId: "FIRE_BOOST"` → `trait: { name: "炎強化", ... }`

### 設計のコツ

- CSVには「ID」や「文字列」で保存
- データローダーで実際のオブジェクトや型に変換
- 定数マップ（例: `TRAITS["FIRE_BOOST"]`）を用意しておくと便利

---

## ファイル構成の例

```
/public/data/
  skills.csv      ← スキルマスター
  enemies.csv     ← 敵マスター
  items.csv       ← アイテムマスター

/utils/
  csvParser.ts    ← 汎用CSVパーサー
  dataLoader.ts   ← ゲーム固有の変換ロジック
```

---

## 実装の流れ

### Step 1: CSVパーサーを作る

- 入力: CSVテキスト
- 出力: `Record<string, unknown>[]`（型変換済みオブジェクト配列）
- 2行目の型定義に従って、string/number/booleanを変換
- ダブルクォートで囲まれたフィールドを正しく処理（RFC 4180対応）

### Step 2: 型定義を作る

- ゲームで使う型をTypeScriptで定義
- 例: `interface Skill { name: string; damage: number; effect?: SkillEffect; }`

### Step 3: データローダーを作る

- CSVパーサーで読み込んだ生データを受け取る
- ゲームの型に変換して返す
- JSON文字列のパース、ID→オブジェクト参照の解決などを行う

### Step 4: 初期化時にロード

- アプリ起動時に`fetch`でCSVを取得
- パース＆変換してステートに保存
- ローディング画面を表示しておく

---

## JSONフィールドの扱い方

スキル効果など複雑なデータはJSON文字列としてCSVに保存します。

### CSVでの書き方

```csv
effectType,effectParams
string,string
add_buff,{"buffId":"CHARGE"}
deck_bonus,"{""value"":30,""target"":""スラッシュ""}"
```

### データローダーでの処理

1. effectParamsが空でなければJSON.parseを試みる
2. パース成功 → オブジェクトとして使用
3. パース失敗 → 警告を出して空オブジェクト

---

## メリット

1. **非エンジニアでも編集可能**: Excelやスプレッドシートで開ける
2. **差分管理しやすい**: テキストなのでGitで差分が見やすい
3. **ホットリロード対応**: CSVを書き換えてリロードすれば即反映
4. **型安全**: 2行目の型定義とTypeScriptで二重にチェック

## デメリット・注意点

1. **カンマ・改行の扱い**: ダブルクォートエスケープが必要
2. **リレーション**: RDBのような外部キー参照は自前で実装が必要
3. **大量データ**: 数万行を超えるとパース負荷が問題になる可能性
4. **バリデーション**: 型以外の制約（範囲チェック等）は別途実装

---

## Tips

- **空のカラム**: 数値は`0`、文字列は空文字、booleanは`false`になるようにパーサーを作ると便利
- **コメント行**: 必要なら`#`で始まる行を無視する機能を追加
- **バージョン管理**: CSVの先頭に`#version:1.0`のようなメタ情報を入れる手もある
- **エディタ**: VSCodeの「Rainbow CSV」拡張を入れると編集しやすい

---

## 参考: 本プロジェクトの実装ファイル

| ファイル | 役割 |
|---------|------|
| `utils/csvParser.ts` | RFC 4180準拠の汎用CSVパーサー |
| `utils/dataLoader.ts` | スキル・敵データの変換ロジック |
| `public/data/skills.csv` | スキルマスターデータ |
| `public/data/enemies.csv` | 敵マスターデータ |
